このesolangはTSG夏合宿2018のために作られました。


### 2020/5/3アップデート
言語仕様をきれいにしました．
旧ドキュメントは[README-old.md](./README-old.md)にあります．

# Bots
TSGのslackの#sandbox ではさまざまなbotが動いています。
### 例)
http://hakatashi.hatenadiary.com/entry/2017/12/03/173400
http://kurogoma.hatenablog.com/entry/2017/12/08/000000
http://hakatashi.hatenadiary.com/entry/2017/12/03/185033

初期にはbotが暴走してメッセージを垂れ流すなどの事件も起こっていました。
今回の"Bots"はこれを参考にして作りました。

# Syntax(文法)
```
<program> ::= <stack>

<stack> ::= <element>*

<element> ::= <ident> | <number> | <operator> | <funcdef>

<funcdef> ::= <ident> "(){" <stack> "}" | <ident> "(" <arguments> "){" <stack> "}"
<arguments> ::= <ident> | <ident> "," <arguments>

<ident> ::= [0-9A-Za-z]+
<number> ::= [0-9]+
<operator> ::= [+-*/@?] | "ic" | "id" | "oc" | "od"
```

## Syntaxの日本語訳
プログラムは1つのstackです．
stackは，複数個のelementの列です．
elementには4種類あります．
- ident
関数名や変数名として用いる，アルファベットと数字からなる文字列
- number  
数字を表す数字からなる文字列
- operator  
組み込み関数
- funcdef  
関数定義

関数定義は，まず関数名，その次に0個以上の関数の引数を","で区切って"()"でかこったもの，その後に関数のボディであるstackを"{}"でかこったもの，を並べた列です．

# Semantics(プログラムの挙動)

<!-- 
プログラムの状態は，「スタック」と「環境」からなります．「スタック」は「データ」のスタックとし，「環境」はidから関数定義への部分関数とします．プログラムの「データ」は「文字列」もしくは「数値」です．

初期状態では，「スタック」はソースコードで記述されたスタックとし，「環境」は組み込み関数の定義(後述)のみとします．

プログラムは，「スタック」のトップにある「データ」に従って「スタック」と「環境」を書き換える，というステップを繰り返すことによって実行されます．

以下の説明では，「スタック」の書き換えの1ステップを

`e x1 x2 x3 ... xn S` -> `y1 y2 ... ym S`

の形で書くことにします．これは，『「スタック」のトップにある「データ」がeのとき，「スタック」の先頭からn+1個の「データ」をe,x1,...,xnとし，「スタック」の残りの「データ」列をSとすると，1ステップ後には「スタック」は `y1 y2 ... ym S` というデータ列になっている』ということを意味しています．
-->

プログラムの状態はデータの列であるスタックで表現されます．データは「識別子」もしくは「数値」もしくは「関数定義」です．初期状態では，状態スタックはソースコードで記述されたスタックとします．

プログラムは，状態スタックのトップにあるデータに従って状態スタックを書き換える，というステップを繰り返すことによって実行されます．

以下の説明では，状態スタックの書き換えの1ステップを

`e x1 x2 x3 ... xn S` -> `y1 y2 ... ym S`

の形で書くことにします．これは，『状態スタックのトップにある「データ」がeのとき，「スタック」の先頭からn+1個の「データ」をe,x1,...,xnとし，「スタック」の残りの「データ」列をSとすると，1ステップ後には「スタック」は `y1 y2 ... ym S` というデータ列になっている』ということを意味しています．

## 組み込み関数の挙動

### + - * /
加減乗除を行います．除算は切り捨てで，0除算をしようとするとプログラムがエラーで落ちます．

`+ a b f S` -> `f (a+bの値) S`

`- a b f S` -> `f (a-bの値) S`

`* a b f S` -> `f (a*bの値) S`

`/ a b f S` -> `f (a/bの値) S`

たとえば，
`+ 4 5 - 6 * 7 / 8` は
```
+ 4 5 - 6 * 7 / 8
    - 9 6 * 7 / 8
        * 3 7 / 8
           21 / 8
                2
``` 
となります．

## ic,id
文字,数字を入力します。

`ic f S` -> `f (読みこんだ文字の文字コード) S`

`id f S` -> `f (読みこんだ数字の値) S`

たとえば，`123`を入力した場合、(`1`の文字コードは49)  
`ic + 2` は
```
ic + 2
+ 49 2
51
``` 
`id + 2` は
```
id + 2
+ 123 2
125
``` 
となります．

## oc,od
文字,数字を出力します。

`oc x S` -> `S` (画面に文字コードがxの文字が出力される)

`od x S` -> `S` (画面に10進表記したxの値が出力される)

たとえば，`oc 49` は
```
oc 49

```
となり，画面に"1"が出力され， 
`od 49` は
```
od 49

``` 
となり，画面に"49"が出力されます． 

## ?

条件分岐です．

`? a f g S` -> `f S` (aが0でないとき)

`? a f g S` -> `g S` (aが0のとき)

たとえば，
`id ? oc od 49` は，
もし0が入力されたら
```
id ? oc od 49
 ? 0 oc od 49
        od 49

``` 
となり，49が出力されます．

もし1が入力されたら
```
id ? oc od 49
 ? 1 oc od 49
        oc 49

``` 
となり，1が出力されます．

## @
プログラムを終了させます．

`@ a S` -> `S` (exitコードがaでプログラムが終了する)

たとえば，
`@ 123` は，exitコードが123でプログラムを終了させます．

# 関数定義と関数実行の挙動

## funcdef, ident

関数定義と関数適用を行います．

「スタック」のトップが  
`f(a1, ... ,an){ d1 ... dm }`  
という関数定義の場合，「データ`f`がスタックトップにあった際の挙動」が変更されます．
(このため，正確にはプログラムの状態は「スタック」と「環境」の2つ組，とするべきですが，簡便のため省きました．)

`funcdef S` -> `S` (ただし環境がアップデートされる)

関数`f`が`f(a1, ... ,an){ d1 ... dm }` として定義されているとき，

`f x1 ... xn S` -> `d1[x1/a1, ... xn/an] ... dm[x1/a1, ... xn/an] S`

とします．ここで，`d[x1/a1, ... xn/an]` は，
- `d`が数値のとき  
`d`のまま
- `d`が識別子のとき  
あるkについて`xk`が`d`と同じであれば，`ak`  
どれも違う時，`d`のまま
- `d`が関数定義のとき  
`d`のbodyにあたるスタック中のデータに対して，再帰的に`[x1/a1, ... xn/an]`による置換を施す

とします．

たとえば，(以下書きかけ)


# Tips
- 関数型言語、継続渡し、動的束縛などが元ネタなので知っておくとよいです．